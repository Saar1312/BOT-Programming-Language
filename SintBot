#!/usr/bin/env python3
#---------------------------------------------------------------------
# Universidad Simón Bolívar                                                          
#    Dpto. de Computación y Tecnología de la Información                                
#    CI3725 - Traductores e Interpretadores                                                                                 	                                 
#                                                                                       
#    Integrantes:                                                                       
#        Sergio Teran, 11-11020                                                       
#        Samuel Arleo R, 10-10969                             
#---------------------------------------------------------------------

from Parser import *
from Tabla import *
from Pila import *
from Arbol import *
# Creando una instancia de clase Tokenizer
tokenizer = Tokenizer()

# Cargando archivo
if len(sys.argv) > 1:
	tokenizer.data = tokenizer.cargarArchivo(sys.argv[1])
	
	# Construyendo analizador lexicografico dentro de la clase
	tokenizer.build()

	# Borrando los tokens innecesarios para el parser
	tokens = tokenizer.tokens
	tokens.remove('TkCommentL')
	tokens.remove('TkCommentC')
	tokens.remove('TkMe')

	# Construyendo el parser con la gramatica definida en Parser.py
	parser = yacc.yacc(errorlog = yacc.NullLogger())

	# result es la raiz del arbol creado a partir de la gramatica de atributos
	result = parser.parse(tokenizer.data)


	#------------------------------------------------------------------------------------------------------------#
	# Asumiendo que:
	# - No se puede usar un robot anteriormente declarado dentro de las instrucciones del mismo robot o de otros
	# - El tipo del me y las demas variables declaradas con Collect o read sera el mismo que el del robot

#-------------------------------------------
#
# Funcion para verificar si es arbol
#
#-------------------------------------------
	def es_arbol(h):
		if type(h) in [arbol,expresion,instContr,\
					instRobot]:
			return True
		return False

	tabla = Tabla(None)
	pointer = tabla
	tipo = None
	incAlcance = False
	p = pila()
	def crearTabla(arbol,almacenar):
		global tipo,pointer,p,incAlcance

		if es_arbol(arbol) and arbol.nombre == 'INC_ALCANCE':
			incAlcance = True
		
		if es_arbol(arbol) and arbol.nombre == 'INSTRUCCIONES_ROBOT': # Crea la tabla para la inc de alcance solo si hay una inc de 
			almacenar = True 					  # alcance y en esta se declaran robots
			if incAlcance:
				p.addTope(pointer)
				t = Tabla(pointer)
				pointer = t
				incAlcance = False
		elif es_arbol(arbol) and arbol.nombre == 'INICIO':
			almacenar = True
		elif es_arbol(arbol) and arbol.nombre == 'EXECUTE':
			almacenar = False
		
		print('\n',pointer.tabla)
		
		if es_arbol(arbol):
			print(arbol.nombre)
		
		if es_arbol(arbol) and pointer.tablaExterna:
			print('PADRE:',pointer.tablaExterna.tabla,'\n')
		
		if es_arbol(arbol) and almacenar:
			if arbol.nombre == 'DECLARACION_ROBOT':
				tipo = arbol.hijos[0].tipo
				simbolo = arbol.hijos[1].hijos[0]
				t = Tabla(None) 						# t es la tabla de simbolos para las instrucciones de cada robot
				t.agregar('me',None,tipo)				# No tiene padre porque la idea es que las instrucciones de robot no 
				pointer.agregar(simbolo,None,tipo,t)	# usen a los robots declarados.
														# t no recibe ninguna tabla, por lo que tiene 3 argumentos
			elif arbol.nombre == 'LISTA':
				simbolo = arbol.hijos[0].hijos[0]
				t = Tabla(None)
				t.agregar('me',None,tipo)
				pointer.agregar(simbolo,None,tipo,t)
			elif (arbol.nombre == 'COLLECT' and 
				 arbol.hijos != []):
				if arbol.hijos[0].nombre == 'COLLECT_AS':
					simbolo = arbol.hijos[0].hijos[0].hijos[0]
					for robot,datos in pointer.tabla.items():
						datos.tabla.agregar(simbolo,None,tipo)
			elif (arbol.nombre == 'READ_AS' and
				 arbol.hijos != []):
				simbolo = arbol.hijos[0].hijos[0]
				for robot,datos in pointer.tabla.items():
					datos.tabla.agregar(simbolo,None,tipo)
		
		if es_arbol(arbol):
			for rama in arbol.hijos:
				if rama != None and not type(rama) in [defTipo,expresion]: # cambiar para que cicle en expresiones distintas de strings,int,bool,etc
					if rama == 'incAlcance':
						pointer = p.popTope()
					else:
						crearTabla(rama,almacenar)



# Usar la tabla en cada nodo del arbol para colocar el tipo actual en los nodos de expresiones

	crearTabla(result,None)
	#print("HOLAAAAAAAAAAAAAAAAAAAAAAAAA",pointer.tabla)
	# print(pointer.tabla['a'].tabla.tabla)
	#print(pointer.tabla['v'])
	#print(pointer.tabla['c'].tabla.tabla)
	"""
												
		elif arbol.nombre == 'COMPORTAMIENTO':
			for robot,datos in pointer.tabla.items():
				datos.

		
	"""
	#------------------------------------------------------------------------------------------------------------#

	# Si hay un error de sintaxis y el arbol no se logra crear correctamente, result
	# sera None y dara error al aplicar imprimirArbol()
	if result:
		result.imprimirArbol(0)
	else:
		print("No ha podido generarse el arbol sintactico")

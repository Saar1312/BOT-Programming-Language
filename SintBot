#!/usr/bin/env python3
#---------------------------------------------------------------------
# Universidad Simón Bolívar                                                          
#    Dpto. de Computación y Tecnología de la Información                                
#    CI3725 - Traductores e Interpretadores                                                                                 	                                 
#                                                                                       
#    Integrantes:                                                                       
#        Sergio Teran, 11-11020                                                       
#        Samuel Arleo R, 10-10969                             
#---------------------------------------------------------------------

import sys
from Parser import *
from Tabla import *
from Pila import *
from Arbol import *
# Creando una instancia de clase Tokenizer
tokenizer = Tokenizer()

# Cargando archivo
if len(sys.argv) > 1:
	tokenizer.data = tokenizer.cargarArchivo(sys.argv[1])
	
	# Construyendo analizador lexicografico dentro de la clase
	tokenizer.build()

	# Borrando los tokens innecesarios para el parser
	tokens = tokenizer.tokens
	tokens.remove('TkCommentL')
	tokens.remove('TkCommentC')
	tokens.remove('TkMe')

	# Construyendo el parser con la gramatica definida en Parser.py
	parser = yacc.yacc(errorlog = yacc.NullLogger())

	# result es la raiz del arbol creado a partir de la gramatica de atributos
	result = parser.parse(tokenizer.data)


	#------------------------------------------------------------------------------------------------------------#
	# Asumiendo que:
	# - No se puede usar un robot anteriormente declarado dentro de las instrucciones del mismo robot o de otros
	# - El tipo del me y las demas variables declaradas con Collect o read sera el mismo que el del robot
	def esArbol(h):
		if type(h) in [arbol,expresion,instContr,\
					instRobot]:
			return True
		return False

	tabla = Tabla(None)
	pointer = tabla
	tipo = None
	incAlcance = False
	p = pila()
	def crearTabla(arbol,almacenar):
		global tipo,pointer,p,incAlcance
		if arbol.nombre == 'INSTRUCCIONES_ROBOT': # Crea la tabla para la inc de alcance solo si hay una inc de 
			almacenar = True 					  # alcance y en esta se declaran robots
			if incAlcance:
				p.addTope(pointer)
				t = Tabla(pointer)
				pointer = t
				incAlcance = False
		elif arbol.nombre == 'INICIO':
			almacenar = True
		elif arbol.nombre == 'EXECUTE':
			almacenar = False
		elif arbol.nombre == 'CONDICION': # Arbol de las instrucciones On activation/default/...
			p.addTope(pointer)
			t = list(pointer.tabla.values())[0].tabla # Mueve el apuntador a la tabla de simbolos asociada a cualquiera de las variables
			pointer = t
		if esArbol(arbol):
			if almacenar:
				if arbol.nombre == 'DECLARACION_ROBOT':
					tipo = arbol.hijos[0].tipo
					arbol.hijos[1].tipo = tipo
					simbolo = arbol.hijos[1].hijos[0]
					t = Tabla(None) 						# t es la tabla de simbolos para las instrucciones de cada robot
					t.agregar('me',None,tipo)				# No tiene padre porque la idea es que las instrucciones de robot no 
					pointer.agregar(simbolo,None,tipo,t)	# usen a los robots declarados.
															# t no recibe ninguna tabla, por lo que tiene 3 argumentos
					
				elif arbol.nombre == 'LISTA':
					simbolo = arbol.hijos[0].hijos[0]
					arbol.hijos[0].tipo = tipo # Agregando el tipo a la variable
					t = Tabla(None)
					t.agregar('me',None,tipo)
					pointer.agregar(simbolo,None,tipo,t)

				elif (arbol.nombre == 'COLLECT' and 
					 arbol.hijos != []): 
					if arbol.hijos[0].nombre == 'COLLECT_AS':
						tope = p.getTope()
						p.addTope(pointer)
						pointer = tope
						simbolo = arbol.hijos[0].hijos[0].hijos[0]
						arbol.hijos[0].hijos[0].tipo = tipo
						for robot,datos in pointer.tabla.items():
							datos.tabla.agregar(simbolo,None,tipo)
						pointer = p.popTope()
				elif (arbol.nombre == 'READ_AS' and
					 arbol.hijos != []):
					tope = p.getTope()
					p.addTope(pointer)
					pointer = tope
					simbolo = arbol.hijos[0].hijos[0]
					arbol.hijos[0].tipo = tipo
					for robot,datos in pointer.tabla.items():
						datos.tabla.agregar(simbolo,None,tipo)
					pointer = p.popTope()
			# PARA DEBUGGING
			#print(arbol.nombre)
			#print(pointer.tabla)
			#if pointer.tablaExterna:
			#	print(pointer.tablaExterna.tabla)
			#if arbol.nombre == 'INC_ALCANCE':
			#	incAlcance = True
			#for var,datos in pointer.tabla.items():
			#	if datos.tabla:
			#		print("VARIABLE:",var)
			#		print("Tabla",datos.tabla.tabla)
			#print("-------------------")
			for rama in arbol.hijos:
				if rama in ['incAlcance','instRobot']: # incAlcance es un hijo de los arboles
					pointer = p.popTope()# de inc de alcance que permite saber
				else:					 # si termino la inc de alcance para mover 
					if esArbol(rama):
						crearTabla(rama,almacenar) # el apuntador de tablas
						if type(rama) == expresion:
							if rama.nombre in ['CONJUNCION','DISYUNCION']:
								if rama.hijos[0].tipo == rama.hijos[1].tipo:
									if rama.hijos[0].tipo != 'bool':
										print("Error de tipos en la linea %d:" % (rama.linea))
										print("No es posible operar elementos del tipo ",\
																  rama.hijos[0],end=" ")
										print("con un operador booleano.")
										#sys.exit()
								else:
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("No es posible operar un elemento del tipo ",\
															  rama.hijos[0],end=" ")
									print("con otro de tipo ",rama.hijos[1])
									#sys.exit()

							elif rama.nombre in ['DISTINTO','IGUALDAD']:
								if rama.hijos[0].tipo != rama.hijos[1].tipo:
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("No es posible operar un elemento del tipo ",\
															  rama.hijos[0].tipo,end=" ")
									print("con otro de tipo ",rama.hijos[1].tipo)
									#sys.exit()

							elif rama.nombre in ['MENOR_QUE','MENOR_IGUAL','MAYOR','MAYOR_IGUAL']:
								if rama.hijos[0].tipo == rama.hijos[1].tipo:
									if rama.hijos[0].tipo != 'int':
										print("Error de tipos en la linea %d:" % (rama.linea))
										print("No es posible operar elementos del tipo ",\
																  rama.hijos[0].tipo,end=" ")
										print("con un operador booleano.")
										sys.exit()
								else:
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("No es posible operar un elemento del tipo ",\
															  rama.hijos[0].tipo,end=" ")
									print("con otro de tipo ",rama.hijos[1].tipo)
									#sys.exit()

							elif rama.nombre in ['SUMA','RESTA','MULTIPLICACION','DIVISION','MODULO']:
								if rama.hijos[0].tipo == rama.hijos[1].tipo:
									if rama.hijos[0].tipo != 'int':
										print("Error de tipos en la linea %d:" % (rama.linea))
										print("No es posible operar elementos del tipo ",\
																  rama.hijos[0].tipo,end=" ")
										print("con un operador aritmetico.")
										sys.exit()
								else:
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("No es posible operar un elemento del tipo ",\
															  rama.hijos[0].tipo,end=" ")
									print("con otro de tipo ",rama.hijos[1].tipo)
									#sys.exit()

							elif rama.nombre == 'NEGACION':
								if rama.hijos[0].tipo != 'bool':
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("Se esperaba una expresion de tipo booleano,",end=' ')
									print("pero fue dada una de tipo \"%s\"" % (rama.hijos[0].tipo))
									#sys.exit()

							elif rama.nombre == 'NEGATIVO':
								if rama.hijos[0].tipo != 'int':
									print("Error de tipos en la linea %d:" % (rama.linea))
									print("Se esperaba una expresion de tipo entero,",end=' ')
									print("pero fue dada una de tipo \"%s\"" % (rama.hijos[0].tipo))
									#sys.exit()

							elif rama.nombre == 'PARENTESIS':
								rama.tipo = rama.hijos[0].tipo

							elif rama.nombre == 'VAR':
								t = pointer.buscarEnTodos(rama.hijos[0],'getTipo')
								if t: 				 # Busca el tipo en la tabla de simbolos apuntada 
									rama.tipo = t	 # actualmente y en las superiores. Si lo encuentra,
													 # retorna el tipo. Si no, retorna None y no entra
								else: 				 # en el condicional y debe dar error, porque la 
									print("Error en la linea %d: La variable \"%s\" no ha sido declarada." \
																% (rama.linea, rama.hijos[0]))
									#sys.exit()
							elif rama.nombre == 'ON_CONDICION':
								if rama.hijos[0].tipo != 'bool':
									print("Error en la linea %d: La condicion del robot debe evaluar en un booleano.")
									##sys.exit()

	crearTabla(result,None)
	#------------------------------------------------------------------------------------------------------------#

	# Si hay un error de sintaxis y el arbol no se logra crear correctamente, result
	# sera None y dara error al aplicar imprimirArbol()
	if result:
		result.imprimirArbol(0)
	else:
		print("No ha podido generarse el arbol sintactico")
